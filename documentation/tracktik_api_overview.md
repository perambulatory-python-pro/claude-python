Introduction
The TrackTik API is RESTful and has predictable resource URLs. It returns HTTP response codes to indicate errors. It also accepts and returns JSON in the HTTP body. You can use your favorite HTTP/REST library for your programming language to use TrackTik's API, or you can use one of our SDKs. It uses HTTPS (HTTP over TLS) for secure communication over the internet.

Most of the objects are supported by an API which is documented and available for use so that you may automate any work flows necessary. This document contains the most commonly integrated resources.

Versioning
When we make backwards-incompatible changes to the API, we release a new dated version. The current version is 2020-01-01.

Read our API Versioning documentation to learn more about backwards compatibility.

All requests will use the latest API version, unless you specify an API version. The API Changelog lists every available version.

To request a specific API version, set an Accept header with the version number:

Accept: application/vnd.tracktik.v2020-01-01+json
To consult the API Documentation for a specific version, add the version number with the format YYYYMMDD to the documentation URL.

Example of URL for the API Documentation of version 2020-01-01: https://[your-domain]/rest/v1/2020-01-01.

Authentication
To use the API, you will need to retrieve an access token and use it to authenticate all your requests.

The TrackTik API now supports two forms of authentication:

OAuth2 (recommended), via the HTTP Authorization header.
JWT (deprecated), via the HTTP Authorization header.
Usage
Idempotent Requests
The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. When creating or updating an object, use an idempotency key. Then, if a connection error occurs, you can safely repeat the request without risk of creating a second object or performing the update twice.

To perform an idempotent request, provide an additional Idempotency-Key: <key> header to the request.

curl -X POST \
https://tracktik.staffr.com/rest/v1/clients \
-H 'Accept: application/json' \
-H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6IlJTMjU2LVNZUy0yMDE4MDEwMSJ9.eyJpc3MiOiJ0cmFja3Rpay5zdGFmZnIuY29tOjgwIiwiYXVkIjpbInRyYWNrdGlrLnN0YWZmci5jb206ODAiXSwiaWF0IjoxNTQ2ODkyNDEzLCJzdWIiOiIxMDAwIiwiZXhwIjoxNTY0MTcyNDEzfQ.i9AOAspsE7h7sDoW9e0wa0Y7VkgOJL7EVWG2QmlkfD48YTvjZS_c5f47YblUwwaszIsH0FqwamC8ygRtjF0r90eK60kgdAVFaRK4BsI-vutXNNdh2YJ5-OXmbW04u5Q3hCUtzA0Q5PezGhIaffG8CakVHixmXhR2hDWCU6Zlz7xi6vwaOyPF5bST7hPDU8vDFVxrXzBWHbDkSMhlqnNC4cESL832JY2XmHxDPq6-4_yYVhJkp3kdESfSNvHgvivke7eFf0vPyS7DSEXV99gHIkNEvqJvCG8I6kHjUym4AY7Fp0nuCRPiNz-9_-XoHdvNj_WtNhQ8_tG4RVbsSWb6vyl6VnBtBzCgxETtzTYbnqQF4IXMrS7hmA19f3v-uYW4x-_RcEtog6LVET8MVyzBd_qW8hRnXkLmVJJLbXRgCAlHeoLR9mZDlONAUG7bM0Q5XW12jk6eVxWK3yyGLEb44TYsHpBTZ9ev7N9AcSLdgKd3_7v4umeZzllLOWtpsca5rDjxN8h6KfNNYS_t4hf9IcOCIHP_fIz_YVE5z_bU2G5WAHEUfMMs6_ql-2W9gqVuidRIAe6Skf5wQLdzOJpNJ9V6U6KqB_EGCdAcailSllWGkn-gOIUtD-iPFcS1Zxl5hjF53J6hWRPJLjBrMV2NESU28nnAvz7EUH2xzs3OhtI' \
-H 'Idempotency-Key: myApp-2b905799-a57d-4e6c-a7f2-4d7920349d98'
...
Idempotency works by saving the resulting status code and body of the first request made for any given idempotency key, regardless of whether it succeeded or failed. Subsequent requests with the same key return the same result, including 4XX and 5XX errors.

An idempotency key is a unique value generated by the client which the server uses to recognize subsequent retries of the same request being performed by the same user. We suggest using V4 UUIDs prefixed by your client app ID or name, example: myApp-2b905799-a57d-4e6c-a7f2-4d7920349d98

Keys are automatically removed from the system automatically after 24 hours, and a new request is generated if a key is reused after the original has been pruned. The idempotency layer compares incoming parameters to those of the original request and errors unless they're the same to prevent accidental misuse.

Results are only saved if an API endpoint started executing. If the request conflicted with another that was executing concurrently, no idempotent result is saved because no API endpoint began execution. It is safe to retry these requests.

All POST requests accept idempotency keys. Sending idempotency keys in GET and DELETE requests has no effect and should be avoided, as these requests are idempotent by definition.

Context Headers
The TrackTik API implements some custom HTTP headers to define some globals context for the request.

TTC-Region-Filter HTTP header.
Users can have access to different regions, so this header allow to filter the request to one or more regions instead of doing it for all the regions that the user has access. Valid values are the region ID, or regions IDs separated by comma, example:

1000 for region with ID 1000
1000,1111,2222 for regions with IDs 1000, 1111, and 2222
If multiple regions IDs are send on the header and one or more of them are not valid region IDs or the user don't have access to these regions, an exception will be logged on the system and the request will be filtered using only the valid region IDs.

If all the regions IDs send on the header are invalid or the user don't have access to these regions the request will be filtered taking into account all the regions the user have access and ignoring the values on the header.

curl -X POST \
https://tracktik.staffr.com/rest/v1/clients \
-H 'Accept: application/json' \
-H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6IlJTMjU2LVNZUy0yMDE4MDEwMSJ9.eyJpc3MiOiJ0cmFja3Rpay5zdGFmZnIuY29tOjgwIiwiYXVkIjpbInRyYWNrdGlrLnN0YWZmci5jb206ODAiXSwiaWF0IjoxNTQ2ODkyNDEzLCJzdWIiOiIxMDAwIiwiZXhwIjoxNTY0MTcyNDEzfQ.i9AOAspsE7h7sDoW9e0wa0Y7VkgOJL7EVWG2QmlkfD48YTvjZS_c5f47YblUwwaszIsH0FqwamC8ygRtjF0r90eK60kgdAVFaRK4BsI-vutXNNdh2YJ5-OXmbW04u5Q3hCUtzA0Q5PezGhIaffG8CakVHixmXhR2hDWCU6Zlz7xi6vwaOyPF5bST7hPDU8vDFVxrXzBWHbDkSMhlqnNC4cESL832JY2XmHxDPq6-4_yYVhJkp3kdESfSNvHgvivke7eFf0vPyS7DSEXV99gHIkNEvqJvCG8I6kHjUym4AY7Fp0nuCRPiNz-9_-XoHdvNj_WtNhQ8_tG4RVbsSWb6vyl6VnBtBzCgxETtzTYbnqQF4IXMrS7hmA19f3v-uYW4x-_RcEtog6LVET8MVyzBd_qW8hRnXkLmVJJLbXRgCAlHeoLR9mZDlONAUG7bM0Q5XW12jk6eVxWK3yyGLEb44TYsHpBTZ9ev7N9AcSLdgKd3_7v4umeZzllLOWtpsca5rDjxN8h6KfNNYS_t4hf9IcOCIHP_fIz_YVE5z_bU2G5WAHEUfMMs6_ql-2W9gqVuidRIAe6Skf5wQLdzOJpNJ9V6U6KqB_EGCdAcailSllWGkn-gOIUtD-iPFcS1Zxl5hjF53J6hWRPJLjBrMV2NESU28nnAvz7EUH2xzs3OhtI' \
-H 'TTC-Region-Filter: 2' \
...
Accept-Language (or deprecated TTC-Language) HTTP header.
Used to specify the language for the request and response payload, valid values are:

en_us for English (default if header is not set)
fr for Français (French)
ro for Romanian (Român)
es for Español (Spanish)
de for Deutsch (German)
nl for Nederlands (Dutch)
pt for Português (Portuguese)
sv for Svenska (Swedish)
zh-hans for 简体中文 (Chinese Simplified)
th for ไทย (Thaï)
curl -X POST \
https://tracktik.staffr.com/rest/v1/clients \
-H 'Accept: application/json' \
-H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6IlJTMjU2LVNZUy0yMDE4MDEwMSJ9.eyJpc3MiOiJ0cmFja3Rpay5zdGFmZnIuY29tOjgwIiwiYXVkIjpbInRyYWNrdGlrLnN0YWZmci5jb206ODAiXSwiaWF0IjoxNTQ2ODkyNDEzLCJzdWIiOiIxMDAwIiwiZXhwIjoxNTY0MTcyNDEzfQ.i9AOAspsE7h7sDoW9e0wa0Y7VkgOJL7EVWG2QmlkfD48YTvjZS_c5f47YblUwwaszIsH0FqwamC8ygRtjF0r90eK60kgdAVFaRK4BsI-vutXNNdh2YJ5-OXmbW04u5Q3hCUtzA0Q5PezGhIaffG8CakVHixmXhR2hDWCU6Zlz7xi6vwaOyPF5bST7hPDU8vDFVxrXzBWHbDkSMhlqnNC4cESL832JY2XmHxDPq6-4_yYVhJkp3kdESfSNvHgvivke7eFf0vPyS7DSEXV99gHIkNEvqJvCG8I6kHjUym4AY7Fp0nuCRPiNz-9_-XoHdvNj_WtNhQ8_tG4RVbsSWb6vyl6VnBtBzCgxETtzTYbnqQF4IXMrS7hmA19f3v-uYW4x-_RcEtog6LVET8MVyzBd_qW8hRnXkLmVJJLbXRgCAlHeoLR9mZDlONAUG7bM0Q5XW12jk6eVxWK3yyGLEb44TYsHpBTZ9ev7N9AcSLdgKd3_7v4umeZzllLOWtpsca5rDjxN8h6KfNNYS_t4hf9IcOCIHP_fIz_YVE5z_bU2G5WAHEUfMMs6_ql-2W9gqVuidRIAe6Skf5wQLdzOJpNJ9V6U6KqB_EGCdAcailSllWGkn-gOIUtD-iPFcS1Zxl5hjF53J6hWRPJLjBrMV2NESU28nnAvz7EUH2xzs3OhtI' \
-H 'Accept-Language: fr'
...
Deprecated TTC-Language in favor of Accept-Language.

Note: for backward compatibility, until removed, the TTC-Language will take priority over Accept-Language, so if both headers are present and with different values, the one specified on TTC-Language will be used.

curl -X POST \
https://tracktik.staffr.com/rest/v1/clients \
-H 'Accept: application/json' \
-H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6IlJTMjU2LVNZUy0yMDE4MDEwMSJ9.eyJpc3MiOiJ0cmFja3Rpay5zdGFmZnIuY29tOjgwIiwiYXVkIjpbInRyYWNrdGlrLnN0YWZmci5jb206ODAiXSwiaWF0IjoxNTQ2ODkyNDEzLCJzdWIiOiIxMDAwIiwiZXhwIjoxNTY0MTcyNDEzfQ.i9AOAspsE7h7sDoW9e0wa0Y7VkgOJL7EVWG2QmlkfD48YTvjZS_c5f47YblUwwaszIsH0FqwamC8ygRtjF0r90eK60kgdAVFaRK4BsI-vutXNNdh2YJ5-OXmbW04u5Q3hCUtzA0Q5PezGhIaffG8CakVHixmXhR2hDWCU6Zlz7xi6vwaOyPF5bST7hPDU8vDFVxrXzBWHbDkSMhlqnNC4cESL832JY2XmHxDPq6-4_yYVhJkp3kdESfSNvHgvivke7eFf0vPyS7DSEXV99gHIkNEvqJvCG8I6kHjUym4AY7Fp0nuCRPiNz-9_-XoHdvNj_WtNhQ8_tG4RVbsSWb6vyl6VnBtBzCgxETtzTYbnqQF4IXMrS7hmA19f3v-uYW4x-_RcEtog6LVET8MVyzBd_qW8hRnXkLmVJJLbXRgCAlHeoLR9mZDlONAUG7bM0Q5XW12jk6eVxWK3yyGLEb44TYsHpBTZ9ev7N9AcSLdgKd3_7v4umeZzllLOWtpsca5rDjxN8h6KfNNYS_t4hf9IcOCIHP_fIz_YVE5z_bU2G5WAHEUfMMs6_ql-2W9gqVuidRIAe6Skf5wQLdzOJpNJ9V6U6KqB_EGCdAcailSllWGkn-gOIUtD-iPFcS1Zxl5hjF53J6hWRPJLjBrMV2NESU28nnAvz7EUH2xzs3OhtI' \
-H 'TTC-Language: fr'
...
Service patterns
GET /entity-tag
# Return a collection of entities
# Service: EntityCollection
GET /entity-tag/{ID} 
# Return an entity detail
# Service: SingleEntity
POST /entity-tag/{ID}/actions/{actionName}
# Runs an action on a model  @todo
# Service: Action
POST /entity-tag/actions/{actionName}
# Runs a batch action on models with the ID defined on the body as {"ids": [{id1}, {id2}, ...]}
# Service: ActionBatch
GET /entity-tag/action/{actionName}
# Returns the action definition
# Service: ActionDefinition
Sorting Results
When calling the collection services, you can sort the results by using a comma separated value of fields:

GET /resource?sort=-createdAt
# Sorts the results by createdAt desc
For descendant order, append - before the field name

You can add relations or more fields in the request:

GET /resource?sort=-createdAt, region.name
# Sorts the results by createdAt desc and then region.name ascendant
Filtering Results
:EQUAL
You can filter the API using all fields:

GET /resource?customId=ABC001
# Returns objects with customId = to ABC001
You can also filter by relations:

GET /resource?region.id=15
# Returns objects with region ID = 15
You can chain filters:

GET /resource?region.id=15&createdAt=2015-01-01
# Returns objects with region ID = 15 created on 2015-01-01
Filters are chained using the AND condition

:CONTAINS
To query a value that contains a sub-string. You can use the contains pseudo operator in your filter:

GET /resource?region.name:contains=Region
# Returns objects with region name = Example Region or name=Test Region
:ENDSWITH
To query a value that ends a sub-string. You can use the endswith pseudo operator in your filter:

GET /resource?region.name:endswith=Region
# Returns objects with region name = Example Region or name=Test Region
:GT
To query a value greater than a string. You can use the gt pseudo operator in your filter:

GET /resource?region.id:gt=10
# Returns objects with region ID > 15
:GTE
To query a value equal or greater than a string. You can use the gte pseudo operator in your filter:

GET /resource?region.id:gte=10
# Returns objects with region ID >= 10
:IN
To query more than one equal value. You can use the in pseudo operator in your filter:

GET /resource?region.id:in=15,10
# Returns objects with region ID = 15 or ID=10
:ISNOTNULL
To query a value that is not null. You can use the isnotnull pseudo operator in your filter:

GET /resource?client.region:isnotnull
# Returns clients with region
:ISNULL
To query a value that is not null. You can use the isnull pseudo operator in your filter:

GET /resource?client.region:isnull
# Returns clients without region
:LT
To query a value lower than a string. You can use the lt pseudo operator in your filter:

GET /resource?region.id:lt=15
# Returns objects with region ID < 15
:LTE
To query a value equal or lower than a string. You can use the lte pseudo operator in your filter:

GET /resource?region.id:lte=15
# Returns objects with region ID =< 15
:NOT
To query a value that is different from a given string. You can use the not pseudo operator in your filter:

GET /resource?region.id:not=15
# Returns objects with region ID != 15
:STARTSWITH
To query a value that starts with a given string. You can use the startswith pseudo operator in your filter:

GET /resource?region.name:startswith=Region
# Returns objects with region name = Example Region or name=Test Region
:INSET
To query a value in a set (abc, efg, xyz). You can use the inSet pseudo operator in your filter:

GET /employess?tags:inSet=efg
# Returns objects with profile->tags equals to "efg" or "abc,efg" or "abc,efg,xyz"

GET /clients?tags:inSet=abc,efg
# Returns objects with profile->tags equals to "abc,efg" or "abc,xyz,efg"
# Both entries "abc" AND "efg" have to be part of the set

GET /clients?tags:inSet=abc|efg
# Returns objects with profile->tags equals to "abc" or "efg" or "abc,efg,xyz"
# One of the entries "abc" OR "efg" has to be part of the set
Date Filters
:EQUAL
GET /entity-tag?created={{date}}
# Returns objects created on that date
:BEFORE
/entity-tag?created:before={{date}}
# Returns objects created before that date. Non-inclusive
:AFTER
/entity-tag?created:after={{date}}
# Returns objects created after that date. Non-inclusive
:BETWEEN
/entity-tag?created:between={{date1}}|{{date2}}
# Returns objects created between the 2 dates. Inclusive
Supported date formats
2018-01-02 # International format
12/01/2018 # US Format
01-12-2018 # UK Format
Supported time formats
23:30 # 24hr format
11:30am # US format
2330 # Short (24hr) format
Supported relative date/time formats
"yesterday 14:00"
"last day of next month"
For a full list, please refer to this guide

Custom Filters
Custom filters are available on some services. They are useful on many situations, for example, filter a collection by a param that is a relation list.

Each entity defines their own custom filters
You can use more than one at the same time
Example of custom filters for the vendor entity:
Unique custom filter usage
GET /vendors?servicingCityNameContains=Bi
# Returns the vendors serving the cities with a name that contains the string "Bi"
Multiple custom filters usage
GET /vendors?servicingCityNameContains=Bi&serviceById=2
# Returns the vendors serving the cities with a name that contains the string "Bi" and a service ID of 2
Scope Filters
Scopes are pre-made filters that can be applied to any services that return a collection of entities.

Each entity defines their own scopes.
You can filter by multiple scopes
Separate by a comma , for AND condition
Example scopes for the shift entity:
GET /shift?scope=HAS_HOLIDAY
Return the list of vacant shifts AND shifts starting soon:

GET /shift?scope=VACANT,IS_CURRENT
On-demand Fields
On-demand fields can be added to the API object output by specifying with the include query parameter.

GET /employees?include=employmentProfile
All relations (related object) are on-demand fields, so you will need on include them to load the object. If not, only the ID of the relation will be shown.

You can specify multiple on-demand fields by separating them with a comma:

GET /employees?include=employmentProfile,address
Relation list within collection
Only certain relation lists can be included as on-demand fields when retrieving a collection (i.e. workSessions can be included when retrieving shifts).

GET /shifts?include=workSessions
Relation list with aggregate
You can specify an aggregate on a relation list with your relation and after your aggregate function count , for example lines|count to have the number of lines in each object

By default, an aggregate is on the id column, but you can specify a field to apply aggregate, example lines|dateCreation|max to have the last line creation date

Aggregate Functions :

count: Return a count of the number of rows
max : Return the maximum value
min : Return the minimum value
GET /shifts?fields=workSessions|count
GET /shifts?fields=workSessions:myAlias|count
GET /shifts/1?fields=workSessions|count
GET /shifts?fields=:workSessions|startedOn|max
the return key is a concatenation of your relation and your aggregate

workSessions|count: = workSessionsCount = 5
workSessions:myAlias|count: = myAlias = 5
workSessions|startedOn|max = workSessionsStardedOnMax = xxxx-xx-xx xx:xx:xx
Polymorph Fields
Some entities have a polymorphic object as one of their attributes, which means that the attribute can be an object of different types.

These attributes will be represented as an object with a type and object attribute.

The type attribute represents the API resource of the object.
The object attribute represents the id of the object or, if the main attribute is included, the actual object.
Examples:

GET /billable-items/1

{
  "id": 1,
  "serviceModel": {
      "type": "billing-adhoc-items",
      "object": 7
  },
  ...
}
GET /billable-items/1?include=serviceModel

{
  "id": 1,
  "serviceModel": {
    "type": "billing-adhoc-items",
    "object": {
        "id": 7
        "status": "PROCESSED",
        "price": 50,
        "quantity": 1,
        "description": "Billing adhoc item",
        ...
    }
  }
}
Scope /me
Some endpoints can be limited in scope to what the logged-in user has access to. This is useful for limiting data access for users with limited data access.

Return the list of all the shifts of the current user:

GET /me/shifts